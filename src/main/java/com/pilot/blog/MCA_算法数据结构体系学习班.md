## 01_认识复杂度对数器二分法

### 常数操作

int32 内存是连续的结构

1+1  100w+100w 时间是一样的

linked list 不是连续的，每个结点后面有记录下个结点的地址，找200w的结点必然比800w结点的耗时少

### 时间复杂度

定义：比如一个功能复杂度 a*N^2+bN+c(等差数列)省略掉低阶和常数项 就是N^2，复杂度为O(N^2)，复杂度只要最高阶



**常见的常数时间的操作**

算术运算 +-*/%

位运算 >>、>>>、<<、|、&、^

**排序算法**

选择排序O(N^2)，从第0开始循环，0之后依次和0比较，小的那位放到0位置上，再从第1位开始循环，1之后依次和1比较，小的那位放在1位置...双层循环N^2

冒泡排序O(N^2)，相邻2数，谁大谁往右放，第一轮排好n，第二轮排好n-1，没轮最大的肯定在最右边

直接插入排序O(N^2)的基本思想是: 把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。

**额外空间复杂度**

输入参数、输出参数的空间不算额外空间。除此之外，你的流程如果还需要开辟空间才能让你流程继续下去，这部分空间就是额外空间。

**面试、比赛、刷题中，一个问题的最优解是什么？**

一般情况下，先解决时间复杂度，尽可能低，在优化空间复杂度，交这个问题的最优解

常见时间复杂度排行，从好到差：

O(1)<O(logN)<O(N)<O(N*logN)<O(N^2)、O(N^3)...O(N^K)<O(2^N)、O(3^N)...O(K^N)<O(N!)

**认识二分法**

常见的是在一个有序数组上，搜索查数。复杂度为：log2N,（是以2为底，n的对数）

1. 在一个有序数组中，找某个数是否存在
2. 在一个有序数组中，找>=某个数最左侧的位置
3. 在一个有序数组中，找<=某个数最右侧的位置
4. 局部最小值问题

求mid，left + (right-left)/2 比 (left+right)/2 安全，left+right有可能溢出。

 